# 워크플로우의 전체 이름을 정의합니다. GitHub Actions 탭에서 이 이름으로 표시됩니다.
name: Java CI/CD with Gradle to EC2

# 워크플로우가 언제 실행될지를 정의하는 트리거(trigger) 설정입니다.
on:
  push:
    # 'main' 브랜치에 'push' 이벤트가 발생했을 때만 이 워크플로우를 실행합니다.
    branches: ["main"]

# 워크플로우에서 실행될 작업(job)들의 목록입니다.
jobs:
  # 'build-and-deploy'라는 이름의 작업을 정의합니다. 하나의 워크플로우는 여러 작업을 가질 수 있습니다.
  build-and-deploy:
    # 이 작업이 실행될 가상 머신(Runner)의 종류를 지정합니다. GitHub에서 제공하는 최신 우분투 환경을 사용합니다.
    # main 브랜치에 push 되면 GitHub가 Actions 러너(ubuntu-latest VM)를 생성하고,
    # 이 VM 안에서 아래 steps 들이 순차적으로 실행됩니다. 작업이 모두 끝나면 VM은 자동으로 삭제됩니다.
    runs-on: ubuntu-latest

    # 'build-and-deploy' 작업 안에서 순차적으로 실행될 단계(step)들의 목록입니다.
    steps:
      # 1. 소스 코드 체크아웃
      # 'actions/checkout' 액션을 사용하여 현재 리포지토리의 소스 코드를 러너(가상 머신)으로 가져옵니다.
      - name: Checkout Source code
        uses: actions/checkout@v4

      # 2. JDK 17 설정
      # 'actions/setup-java' 액션을 사용하여 러너에 특정 버전의 Java(JDK)를 설치합니다.
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          # 자바 17 버전을 설치합니다.
          java-version: '17'
          # Temurin 배포판을 사용합니다.
          distribution: 'temurin'
          # Gradle 관련 파일(의존성 등)을 캐싱하여 다음 빌드 시 속도를 향상시킵니다.
          cache: 'gradle'

      # 3. Gradle Wrapper 실행 권한 부여
      # Gradle Wrapper 스크립트(gradlew)에 실행 권한을 부여합니다. 이 권한이 없으면 다음 단계에서 빌드를 실행할 수 없습니다.
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      # 4. Gradle로 빌드하기
      # Gradle Wrapper를 사용하여 프로젝트를 빌드합니다. 'build' 태스크는 컴파일, 테스트, .jar 파일 패키징을 모두 수행합니다.
      # 성공적으로 완료되면 'build/libs' 디렉토리에 실행 가능한 .jar 파일이 생성됩니다.
      - name: Build with Gradle
        run: ./gradlew build

      # 5. 빌드된 JAR 파일을 EC2로 전송
      # 'appleboy/scp-action' 액션을 사용하여 빌드된 .jar 파일을 EC2 인스턴스로 안전하게 복사(전송)합니다.
      - name: Transfer JAR to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          # GitHub 리포지토리의 'Settings > Secrets'에 미리 저장해 둔 민감한 정보들을 불러와 사용합니다.
          host: ${{ secrets.EC2_HOST }}         # EC2 인스턴스의 퍼블릭 IP 또는 도메인 주소
          username: ${{ secrets.EC2_USERNAME }} # EC2 접속 유저 이름 (예: ubuntu, ec2-user)
          key: ${{ secrets.EC2_SSH_KEY }}       # EC2 접속을 위한 프라이빗 키 (.pem 파일의 내용)
          # 전송할 파일의 위치를 지정합니다. 여기서는 빌드 결과물인 모든 .jar 파일을 의미합니다.
          source: "build/libs/*.jar"
          # EC2 인스턴스 내에 파일이 저장될 목적지 경로입니다.
          target: "/home/ubuntu/app"

      # 6. EC2에 접속하여 배포 스크립트 실행
      # 'appleboy/ssh-action' 액션을 사용하여 EC2 인스턴스에 원격으로 접속하고, 배포 스크립트를 실행합니다.
      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          # EC2 인스턴스에서 실행될 셸 스크립트 내용입니다.
          script: |
            # 'pgrep'으로 'java' 프로세스의 PID(프로세스 ID)를 찾아서 'kill -9' 명령으로 강제 종료합니다.
            # '|| true'는 실행 중인 java 프로세스가 없어 pgrep이 실패하더라도, 스크립트 전체가 중단되지 않도록 합니다.
            pgrep java | xargs kill -9 || true
            
            # 새로 전송된 .jar 파일을 백그라운드에서 실행합니다.
            # 'nohup'을 사용하여 SSH 세션이 끊겨도 애플리케이션이 계속 실행되도록 합니다.
            # '--spring.profiles.active=prod'는 Spring Boot 애플리케이션의 실행 프로파일을 'prod'(운영 환경)로 설정합니다.
            # '> nohup.out 2>&1 &'는 애플리케이션의 모든 표준 출력(stdout)과 표준 에러(stderr)를 'nohup.out' 파일로 리디렉션하여 로그를 기록하고, 프로세스를 백그라운드에서 실행시킵니다.
            nohup java -jar /home/ubuntu/app/*.jar --spring.profiles.active=prod > /home/ubuntu/app/nohup.out 2>&1 &
